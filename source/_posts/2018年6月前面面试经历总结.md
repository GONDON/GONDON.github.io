---
title: 2018年6月前端面试经历(持续补全中。。。)
date: 2018-06-07 12:30
categories: 面试
---

### 前言

坐标：`杭州` 。今年5月底从上一个公司离职了，离职原因很简单，想换一个环境去多接触一些技术，提高技术的广面和深度。自己从事前端工作差不多2年，本人不是科班出身，算是一个小菜鸡到现在刚入门吧。2年前去面试，因为技术菜，其实公司并没有怎么去了解我的技术，主要还是看个人的态度和学习能力，所以很感谢前面的俩个老东家，把我这个小菜鸡带入门了。今年，在上一个东家做的项目差不多也成型了，发现自己也到了一个一个瓶颈期吧，所以出来闯闯看。
出去面试其实就是一个快捷径去认识到自己的不足，希望能给和我一样在面试的江湖人一点小小的抛砖引玉吧。

### 面试题

1）js的继承是什么？原型链？
```
fucntion super (){
        this.a = '1'
    }
    function sub (){  
        super.call(this)
    }
```
或者

```
function sub (){...}
sub.prototype = new super();
//直接在他的原型上new一个super的实例。
```

在new的过程中，发生了，改变this的指向，执行super里面的代码，返回一个新的函数。

es6的继承方法。

``` 
class sub extends super(){
    constractor(){
        super() // cosole.log(this.props)  undifined
        super(props) // console.log(this.props) 打印出定义好的props
// 它在这里表示父类的构造函数，用来新建父类的this对象。子类必须调用这个方法，不然继承的话会报错。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
        }
// constractor一定是必要的吗？
// 答 是的，就算你不声明，也会隐式的把你声明好一个空的constractor。
//super()和super(props)的区别
```
<!--more-->
2）ajax是什么？
异步的javascript+Xml

```
var xhr - new XmlHttpRequest() 或者  new ActiveXObject()
    xhr.onreadyChange = function(){
        if(xhr.readyState = 4){
        if(xhr.status == 200){
            var test = xhr.responseTest()
        }
    }
}
xhr.open("Get" , url ,false) //第三个参数，是否异步
```

3）如何对一个数组做去重？
（1）set方法
```
    var arr = new Set (arr);
    arr = Array.from(arr);
```
（2）还可以利用对象的key不能想通去做判断
（3）for循环


4）rem和em的区别？
rem是相对于根元素上的font-size的大小。
em是相对于父元素的font-size的大小。
5）盒子模型
    margin + border + padding + context
    
6）http的状态码
200 304 500 404 415 
7）实现一个函数能做到 function add(1)(2)(3) //6

这里要引生出来俩个js内置的方法，valueOf和toString方法，在特定的情况下，这俩个方法都会自动调用，而且在用户定义了新的valueof和tostring的时候，会优先执行新的方法。
在做字符串拼接等需要调用tostring()方法的是有优先调用toString(),如果调用后还是不能返回原始类型的话会继续调用valueOf方法。
而在做类似number的运算的时候会优先调用valueOf().
而对于函数而言，add 和add()的返回是不一样的。add()会返回return的值。而add则会调用valueOf答应出来函数本身的代码.函数的转换类似于number。
解题
```
function add(){
    var args = Array.prototype.slice(arguments); //这里也用到了闭包的概念对args的存储
        var fn = function(){
            var arg_fn = [].prototype.sclice(arguments) 
            //这里是调用fn
            return add.apply(null , args.concat(arg_fn)) //这里的递归是为了合并参数
        }
        fn.valueof= function(){
            return arg.reduce((a,b) => a+b) //真正的输出是valueof
        }
        return fn //这里是返回fn
    }
```

8）执行循序 setTimout和promise
这里我们先要理解js是是单线程执行的。在内存中函数的执行是分同步和异步的。同步任务会放在主线程中一一执行，而异步任务会先注册到事件队列里。等待主线程任务执行完毕，才会去异步队列里拿出任务放在主线程中去执行。
这里还有俩个概念要去理解，`宏事件` `微事件`。
宏事件： script， setTimeout，setInterval
微事件：promise
这里还要多说一句promise是立即执行的函数
```
setTimeout(function() {
        console.log(1)
    }, 0);
            new Promise(function(a, b) {
                console.log(2);
                for(var i = 0; i < 10; i++) {
                    i == 9 && a();
                }
                console.log(3);
            }).then(function() {
                console.log(4)
            });
            console.log(5)
//输出:2,3,5,4,1
```
先执行宏事件，再执行微事件，然后再循环，
9）
```
function Foo() {
    getName = function () { alert (1); };
    return this;
}
    Foo.getName = function () { alert (2);};
    Foo.prototype.getName = function () { alert (3);};
    var getName = function () { alert (4);};
    function getName() { alert (5);}
    //请写出以下输出结果：
    Foo.getName();
    getName();
    Foo().getName();
    getName();
    new Foo.getName();
    new Foo().getName();
    new new Foo().getName();
```
new Foo.getName(); 和 new Foo().getName(); 的区别在于
new Foo 结合属于 new 无参数列表的情况（17级）
new Foo() 结合属于 new 有参数列表的情况（18级）

10)Object.defineProperty()和 {} 出来的对象有什么区别
     可能是defineProperty定义出来的对象 还可以定义是否可枚举，可读写的属性吧
11）jQuery和react的区别。用react有什么好处？jQuery有什么不好？

12）http缓存有什么方法？ 强缓存，协商缓存，304
强缓存：carche-control ：max-age
协商缓存：利用304
13）websoket
一般


14）箭头函数的this的指向问题
    声明时绑定了this，而不是调用时的this
15）call，apply的区别。这俩者和bind的区别。如何用原生实现出来。
call，apply的区别时后面的传参。call时一个一个传，apply时一个数组。
bind能时返回一个新的函数。

16）浏览器渲染原理
显示解析html形成一个dom树，然后解析css 形成一个css树。然后俩者合并形成rende tree，然后在去定位这个元素的位置，然后挂载到浏览器上。

17）css阻塞？js阻塞？如何避免？
18）右边固定，左边自适应。左边固定右边自适应。上面固定高度，下面自适应高度。
```
//左边自适应，右边固定
.float-box{
    display:flex;
    justify-content:end;
}

.left{
    width: 100%;
    border:1px solid #ddd;
}
.right{
    width:300px;
    border:1px solid #ddd;
}
```

19）水平居中？水平垂直居中？
20)一句话打乱一个数组?
```
    arr.sort(function(){ 0.5 - Math.random()})
```

### 算法题
1）有一个公司n个人，员工的姓名和年龄都是一一对应，如何将员工按年龄排序
思路：循环对象取第一个和第二个进行比较，前者大于后者则交换位置
2）排序二叉树。查询，插入，删除
3）快速排序
思路：随机取数组中的一个shu z
4）二分排序法
5）链表的操作
6）字符串查找 
7）解析url后的参数
8）实现一个简单的模版引擎
9）如何快速让字符串变成已千为精度的数字
10）简单的双向数据绑定的实现
```
    请只使用最基本的遍历来实现判断字符串a是否被包含在字符串b中，
    并且返回第一次出现的位置（找不到返回 -1 ）
    ，算法效率尽量高，不要使用 indexOf等一些现成的方法 或者 正则 等方法。
```



### 面试官面试和电话面试
因为我用的技术栈很少，现在基本都是用react去开发的。
1）react的生命周期
```
MOUNTING - 初始化挂载浏览器时的生命周期
getDefaultProps()
getInitialState()
componentWillMount()
render()
componentDidMount()

RECEIVE_PROPS - 接受到参数时的声明周期
componentWillReceiveProps()
shouldComponentUpdate()
componentWillUpdate()
render()
componentDidUpdate()

UNMOUNTING - 卸载组件
componentWillUnmount()
```
2）为什么用state
```
    其实我在项目开发的过程中一般都在用函数生命的组件了，一般尽量少去使用class生命的完整的生命周期的组件，第一是让各个组件自身去管理state，
```
3）无状态组件
4）如何在在生命周期中发送一个异步的请求。
``` 
    一般在componentDidMount()生命周期里去发送一个异步请求。因为这个时候可能需要的dom已经都挂载在了浏览器上，我们可以去拿到一些我们想要的参数，或者是把返回的数据保存在标签中。
```
5）preComponent和component有什么区别

在一个父组件黎有多个子组件的时候，修改一个子组件会导致所有子组件全部重新渲染。
我们一般都会使用shouldComponentUpdate的生命周期去判断，但是这个生命周期是及其消耗性能的，在react里并不推荐使用这个方法。
这个时候我们可以简单的去模拟一个shouldComponentUpdate的方法。
相对于preComponent就是在component的最外层帮我们默认实现了一个浅比较。
React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。
如果React组件的 render() 函数在给定相同的props和state下渲染为相同的结果，在某些场景下你可以使用 React.PureComponent 来提升性能。
React.PureComponent 的 shouldComponentUpdate() 只会对对象进行浅对比。
如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新, 原文：false-negatives)。
当你期望只拥有简单的props和state时，才去继承 PureComponent ，或者在你知道深层的数据结构已经发生改变时使用 forceUpate() 。
或者，考虑使用 不可变对象 来促进嵌套数据的快速比较。
此外,React.PureComponent 的 shouldComponentUpate() 会忽略整个组件的子级。请确保所有的子级组件也是”Pure”的。



6）react的高阶组件是什么？是class还是函数？如何实现一个高阶组件？
高阶组件基础就是高阶函数，是指一个函数接受一个函数作为参数，并返回一个函数。这样的函数称为高阶函数。都说了是函数，就不可能是class了。

7）redux里combineReducers
combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。
合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。
最终，state 对象的结构会是这样的：
```
{
  reducer1: ...
  reducer2: ...
}
```
通过为传入对象的 reducer 命名不同来控制 state key 的命名。例如，你可以调用 combineReducers({ todos: myTodosReducer, counter: myCounterReducer }) 将 state 结构变为 { todos, counter }。

通常的做法是命名 reducer，然后 state 再去分割那些信息，因此你可以使用 ES6 的简写方法：combineReducers({ counter, todos })。这与 combineReducers({ counter: counter, todos: todos }) 一样。

```
Flux 用户使用须知
本函数可以帮助你组织多个 reducer，使它们分别管理自身相关联的 state。类似于 Flux 中的多个 store 分别管理不同的 state。在 Redux 中，只有一个 store，但是 combineReducers 让你拥有多个 reducer，同时保持各自负责逻辑块的独立性。

```
参数
reducers (Object): 一个对象，它的值（value） 对应不同的 reducer 函数，这些 reducer 函数后面会被合并成一个。下面会介绍传入 reducer 函数需要满足的规则。

返回值
(Function)：一个调用 reducers 对象里所有 reducer 的 reducer，并且构造一个与 reducers 对象结构相同的 state 对象。

注意

本函数设计的时候有点偏主观，就是为了避免新手犯一些常见错误。也因些我们故意设定一些规则，但如果你自己手动编写根 redcuer 时并不需要遵守这些规则。

每个传入 combineReducers 的 reducer 都需满足以下规则：

所有未匹配到的 action，必须把它接收到的第一个参数也就是那个 state 原封不动返回。

永远不能返回 undefined。当过早 return 时非常容易犯这个错误，为了避免错误扩散，遇到这种情况时 combineReducers 会抛异常。

如果传入的 state 就是 undefined，一定要返回对应 reducer 的初始 state。根据上一条规则，初始 state 禁止使用 undefined。使用 ES6 的默认参数值语法来设置初始 state 很容易，但你也可以手动检查第一个参数是否为 undefined。

虽然 combineReducers 自动帮你检查 reducer 是否符合以上规则，但你也应该牢记，并尽量遵守。

```
//模拟一个combineReducers
var combineReducers1 = function(obj){
    //内部具体代码

    var finalState = {};
    function reducer(state,action){
        //reducer具体逻辑

        for (var p in obj) {
         //根据key属性值调用function(state.属性名，action)
         finalState[p] = obj[p](state[p], action);
        }

        //返回state
        return finalState;
    }

    //返回最终的reducer
    return reducer;
}
```

8）在react的生命周期里那些不能调用setState
componentWillUnmount()
componentWillUnmount 中调用 setState，是不会触发 re-render 的，这是因为所有更新队列和更新状态都被重置为 null，并清除了公共类，完成了组件卸载操作。
shouldComponentUpdate()，componentWillUpdate()
在react的底层源码里，有一层判断。在着俩个生命周期里调用setState，此时的this.pendingStateQueue != null，则performUpdateIfNecessary方法就会调用UpdateComponent方法进行组件更新，但updateComponent方法优惠调用shouldComponentUpdate和componentWillUpdate方法，因此造成循环调用，是的浏览器内存占满而崩溃。

9) 从react延伸对象的比较，推荐组件定义key的原因。
10）react渲染的循序
递归渲染，父组件先先执行componentWillMount，子组件在执行componentWillMount。
子组件执行完componentDidMount，父组件再去执行componentDidMount.

11）webpack和gulp的区别
12）在工作中遇到那些问题？如何解决的。
13）webpack的excatext webpack pulgin分离静态文本打包分离和按需加载css的区别，哪一个好一点。
14)redux你了解多少？中间件？thunk能做什么？
15）单页应用的原理和如何实现一个简单的单页应用
16）react-router的原理，概念
1.hashchange
2.锚点
17）jsx有什么好的
我个人觉得jsx写法更像是用js去编写html，我们可以在里面利用函数包装复用的展示代码。

### hr面试
1）你觉得你是什么样的人？
2）为什么离职？
3）你最不满意领导的什么地方？
4）你平时周末都干什么？
5）你做的最喜欢的项目是什么？为什么？



 


